# AUTOGENERATED! DO NOT EDIT! File to edit: ../../notebooks/05-density-db-portion-match.ipynb.

# %% auto 0
__all__ = ['root', 'select_food_portion']

# %% ../../notebooks/05-density-db-portion-match.ipynb 7
from pyprojroot import here
root = here()
import sys
sys.path.append(str(root))

# %% ../../notebooks/05-density-db-portion-match.ipynb 8
import pandas as pd
import numpy as np
import seaborn as sns

import nltk
import spacy
from spacy.matcher import Matcher
from spacy.util import filter_spans

from thefuzz import fuzz

from sentence_transformers import SentenceTransformer
from sentence_transformers.util import cos_sim
import torch
from sklearn.metrics.pairwise import cosine_similarity

import json
from itertools import groupby
import re
import string

from tqdm import tqdm
tqdm.pandas()

from ..utils.utils import *

# %% ../../notebooks/05-density-db-portion-match.ipynb 13
with open(f'{root}/data/globals/unit_conversions.json') as f:
    unit_list = json.load(f)

# %% ../../notebooks/05-density-db-portion-match.ipynb 18
def select_food_portion(ingredient, food_portion_df, debug=False):

    if pd.isnull(ingredient['food_id']): return pd.NA

    portions = food_portion_df.loc[ingredient['food_id'],:]
    debug_info = {
        'tag_filter_results': [],
        'description_search_words': '',
        'description_search_results': [],
    }

    if ingredient['unit_type'] == 'volume':
        # if volume given, find (any) other volume portion
        searched = portions.index[portions['unit_tags'].apply(lambda x: any([i in unit_list['volume'].keys() for i in x]))]
        debug_info['tag_filter_results'].append({'filter': 'volume', 'indices': searched})
        if not searched.empty: portions = portions.loc[searched]
    elif ingredient['unit_type'] == 'weight':
        # if weight given, we don't need any matches
        searched = portions.index[portions['unit_tags'].apply(lambda x: any([i in unit_list['weight'].keys() for i in x]))]
        debug_info['tag_filter_results'].append({'filter': 'weight', 'indices': searched})
        if not searched.empty: portions = portions.loc[searched]
    else:
        # if volume nor weight given
        # test: removing results with units
        searched = portions.index[portions['unit_tags'].apply(lambda x: not any([i not in unit_list['portion'].keys() for i in x]))]
        if not searched.empty: portions = portions.loc[searched]
        # first we want to check if units match
        if len(ingredient['unit_tags']):
            searched = portions.index[portions['unit_tags'].apply(lambda x: any([i in ingredient['unit_tags'] for i in x]))]
            debug_info['tag_filter_results'].append({'filter': 'portion_unit_match', 'indices': searched})
            if not searched.empty: portions = portions.loc[searched]
        # then check if remainders match
        if len(ingredient['unit_remainders']):
            searched = portions.index[portions['unit_remainders'].apply(lambda x: any([i in ingredient['unit_remainders'] for i in x]))]
            debug_info['tag_filter_results'].append({'filter': 'portion_unit_remainder_match', 'indices': searched})
            if not searched.empty: portions = portions.loc[searched]
        # if 'whole' portion specified
        if not len(ingredient['unit_tags']) or any([i == 'whole' for i in ingredient['unit_tags']]):
            # if 'whole' explicitly specified:
            searched = portions.index[portions['unit_tags'].apply(lambda x: any([i == 'whole' for i in x]))]
            debug_info['tag_filter_results'].append({'filter': 'portion_whole_explicit', 'indices': searched})
            if not searched.empty: portions = portions.loc[searched]
            else:
                searched = portions.index[(portions['unit_tags'].str.len() == 0)]
                if not searched.empty: 
                    portions = portions.loc[searched]
                    # select the one with the largest gram weight (#todo factor in `amount` too)
                    searched = portions.index[portions['gram_weight'] == portions['gram_weight'].max()]
                    if not searched.empty: portions = portions.loc[searched]

    # searching for ingredient terms
    search_cols = ['name.description', 'comment', 'unit']
    search_words = []
    for col, value in ingredient[search_cols].items():
        if not pd.isnull(value): 
            search_words.extend(ingredient[col].split(' '))
        else:
            if col == 'unit': 
                search_words.extend(['whole', 'serving', 'portion']) 

    search_words.reverse()

    debug_info['description_search_words'] = search_words

    for search_word in search_words:
        for col in ['unit_tags', 'unit_remainders']:
            searched = portions.index[portions[col].apply(lambda x: search_word in x)]
            if not searched.empty:
                portions = portions.loc[searched]
                debug_info['description_search_results'].append({'search_word': search_word, 'indices': searched})

    # finding globals
    default_words = ['raw', 'regular', 'normal', 'medium']
    for word in default_words:
        searched = portions['description'].str.contains(word)
        if searched.any():
            portions = portions[searched]
            debug_info['tag_filter_results'].append({'filter': 'default_units', 'indices': searched.index})
    
    return portions.iloc[0].name if not debug else (portions.iloc[0].name, debug_info)
